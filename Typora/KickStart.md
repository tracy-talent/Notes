# KickStart

## 2019 Round H

> score: 41
>
> rank: 293

### A

* H-index单调不减，使用小堆优先队列维护大于等于当前H-index的值
* 如果下一输入值大于当前H-index则push到队列中，如果此时队顶值等于H-index则弹出，更新H-index为优先队列大小

### B

这题比赛过程中完全没想法！

* 这个题目考察抽象建模的能力，需要基于矩阵建一个图，所有主对角线和副对角线作为图节点，节点存储该对角线所有元素并指向垂直于其的其它对角线
* 然后考虑矩阵中对角线翻转的性质
  * 矩阵中每个元素被一条主对角线和一条副对角线交叉覆盖
  * 对角线翻转两次及以上毫无意义(还原)，只需考虑翻转一次或者两次
* 接着考虑每个点对应2条对角线的翻转情况
  * 点颜色保持不变：同时翻转或者同时不翻转
  * 点颜色变化：有且仅有一条对角线翻转
* 借用以上性质开始dfs图中所有连通分块，程序中可以用0、1表示翻转动作，dfs过程中根据图节点标记动作0或1，1表示dfs过程中前面的动作翻转过后使得该图节点中出现白色块需要执行翻转，0表示不翻转保持黑色，又由点的对角线约束关系可知，在连同分块内执行所有的动作0还是所有的动作1最终该连同分块都会全部变成黑色，取动作次数较小即可

### C

这题比赛过程中使用的dfs暴搜过了小数据，大数据理所当然的卡掉。赛后看题解果然还是dp(简直我的死穴啊)，还要运用巧妙地数论知识化解大数据输入

* 每个数d输入个数10^9太大了，需要运用一点数论知识巧妙化解，每个数d只需保留20个即可覆盖-10~10(可以自己纸上模拟一下)，再多也是重复去一正一负即可，但是当d有奇数个时取21个因为这时取余11等于0有2种可能即正负0

* 接着开始设计dp状态转移：二维dp，t: dp\[p]\[m]表示从1\~t中取p个数作为正数，1\~t中剩余的为负数，最终和取余11为m是否可行，初始化dp\[0]\[0]=true。遍历所有digit，枚举当前digit为正的个数pick，枚举前面所有digit为正的总个数lpick，枚举模11余数(0\~10)lmod，状态方程如下

  ```
  int nmod = (lmod + pick * digit + (cnt[digit] - pick) * (11 - digit)) % 11;
  dp[lpick + pick][nmod] = dp[lpick + pick][nmod] || tdp[lpick][lmod];
  ```

* 分析二维dp数组要开多大，假设一共有sum个digit，那么需要保证(sum+1)/2个正数，加1因为奇数个数时正号要比负号多一个，使用数论知识削减digit个数后每个digit最多保留21个，因此dp第一维下标最大(21\*9+1)/2=95，第二维下标最大10